{"ast":null,"code":"/*global window:false, self:false, define:false, module:false */\n\n/**\n * @license IDBWrapper - A cross-browser wrapper for IndexedDB\n * Version 1.7.2\n * Copyright (c) 2011 - 2017 Jens Arps\n * http://jensarps.de/\n *\n * Licensed under the MIT license\n */\n\n(function (name, definition, global) {\n  'use strict';\n\n  if (typeof define === 'function') {\n    define(definition);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = definition();\n  } else {\n    global[name] = definition();\n  }\n})('IDBStore', function () {\n  'use strict';\n\n  var defaultErrorHandler = function (error) {\n    throw error;\n  };\n  var defaultSuccessHandler = function () {};\n  var defaults = {\n    storeName: 'Store',\n    storePrefix: 'IDBWrapper-',\n    dbVersion: 1,\n    keyPath: 'id',\n    autoIncrement: true,\n    onStoreReady: function () {},\n    onError: defaultErrorHandler,\n    indexes: [],\n    implementationPreference: ['indexedDB', 'webkitIndexedDB', 'mozIndexedDB', 'shimIndexedDB']\n  };\n\n  /**\n   *\n   * The IDBStore constructor\n   *\n   * @constructor\n   * @name IDBStore\n   * @version 1.7.2\n   *\n   * @param {Object} [kwArgs] An options object used to configure the store and\n   *  set callbacks\n   * @param {String} [kwArgs.storeName='Store'] The name of the store\n   * @param {String} [kwArgs.storePrefix='IDBWrapper-'] A prefix that is\n   *  internally used to construct the name of the database, which will be\n   *  kwArgs.storePrefix + kwArgs.storeName\n   * @param {Number} [kwArgs.dbVersion=1] The version of the store\n   * @param {String} [kwArgs.keyPath='id'] The key path to use. If you want to\n   *  setup IDBWrapper to work with out-of-line keys, you need to set this to\n   *  `null`\n   * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will\n   *  automatically make sure a unique keyPath value is present on each object\n   *  that is stored.\n   * @param {Function} [kwArgs.onStoreReady] A callback to be called when the\n   *  store is ready to be used.\n   * @param {Function} [kwArgs.onError=throw] A callback to be called when an\n   *  error occurred during instantiation of the store.\n   * @param {Array} [kwArgs.indexes=[]] An array of indexData objects\n   *  defining the indexes to use with the store. For every index to be used\n   *  one indexData object needs to be passed in the array.\n   *  An indexData object is defined as follows:\n   * @param {Object} [kwArgs.indexes.indexData] An object defining the index to\n   *  use\n   * @param {String} kwArgs.indexes.indexData.name The name of the index\n   * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index\n   * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique\n   * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry\n   * @param {Array} [kwArgs.implementationPreference=['indexedDB','webkitIndexedDB','mozIndexedDB','shimIndexedDB']] An array of strings naming implementations to be used, in order or preference\n   * @param {Function} [onStoreReady] A callback to be called when the store\n   * is ready to be used.\n   * @example\n   // create a store for customers with an additional index over the\n   // `lastname` property.\n   var myCustomerStore = new IDBStore({\n       dbVersion: 1,\n       storeName: 'customer-index',\n       keyPath: 'customerid',\n       autoIncrement: true,\n       onStoreReady: populateTable,\n       indexes: [\n           { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }\n       ]\n   });\n   * @example\n   // create a generic store\n   var myCustomerStore = new IDBStore({\n       storeName: 'my-data-store',\n       onStoreReady: function(){\n           // start working with the store.\n       }\n   });\n   */\n  var IDBStore = function (kwArgs, onStoreReady) {\n    if (typeof onStoreReady == 'undefined' && typeof kwArgs == 'function') {\n      onStoreReady = kwArgs;\n    }\n    if (Object.prototype.toString.call(kwArgs) != '[object Object]') {\n      kwArgs = {};\n    }\n    for (var key in defaults) {\n      this[key] = typeof kwArgs[key] != 'undefined' ? kwArgs[key] : defaults[key];\n    }\n    this.dbName = this.storePrefix + this.storeName;\n    this.dbVersion = parseInt(this.dbVersion, 10) || 1;\n    onStoreReady && (this.onStoreReady = onStoreReady);\n    var env = typeof window == 'object' ? window : self;\n    var availableImplementations = this.implementationPreference.filter(function (implName) {\n      return implName in env;\n    });\n    this.implementation = availableImplementations[0];\n    this.idb = env[this.implementation];\n    this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;\n    this.consts = {\n      'READ_ONLY': 'readonly',\n      'READ_WRITE': 'readwrite',\n      'VERSION_CHANGE': 'versionchange',\n      'NEXT': 'next',\n      'NEXT_NO_DUPLICATE': 'nextunique',\n      'PREV': 'prev',\n      'PREV_NO_DUPLICATE': 'prevunique'\n    };\n    this.openDB();\n  };\n\n  /** @lends IDBStore.prototype */\n  var proto = {\n    /**\n     * A pointer to the IDBStore ctor\n     *\n     * @private\n     * @type {Function}\n     * @constructs\n     */\n    constructor: IDBStore,\n    /**\n     * The version of IDBStore\n     *\n     * @type {String}\n     */\n    version: '1.7.2',\n    /**\n     * A reference to the IndexedDB object\n     *\n     * @type {IDBDatabase}\n     */\n    db: null,\n    /**\n     * The full name of the IndexedDB used by IDBStore, composed of\n     * this.storePrefix + this.storeName\n     *\n     * @type {String}\n     */\n    dbName: null,\n    /**\n     * The version of the IndexedDB used by IDBStore\n     *\n     * @type {Number}\n     */\n    dbVersion: null,\n    /**\n     * A reference to the objectStore used by IDBStore\n     *\n     * @type {IDBObjectStore}\n     */\n    store: null,\n    /**\n     * The store name\n     *\n     * @type {String}\n     */\n    storeName: null,\n    /**\n     * The prefix to prepend to the store name\n     *\n     * @type {String}\n     */\n    storePrefix: null,\n    /**\n     * The key path\n     *\n     * @type {String}\n     */\n    keyPath: null,\n    /**\n     * Whether IDBStore uses autoIncrement\n     *\n     * @type {Boolean}\n     */\n    autoIncrement: null,\n    /**\n     * The indexes used by IDBStore\n     *\n     * @type {Array}\n     */\n    indexes: null,\n    /**\n     * The implemantations to try to use, in order of preference\n     *\n     * @type {Array}\n     */\n    implementationPreference: null,\n    /**\n     * The actual implementation being used\n     *\n     * @type {String}\n     */\n    implementation: '',\n    /**\n     * The callback to be called when the store is ready to be used\n     *\n     * @type {Function}\n     */\n    onStoreReady: null,\n    /**\n     * The callback to be called if an error occurred during instantiation\n     * of the store\n     *\n     * @type {Function}\n     */\n    onError: null,\n    /**\n     * The internal insertID counter\n     *\n     * @type {Number}\n     * @private\n     */\n    _insertIdCount: 0,\n    /**\n     * Opens an IndexedDB; called by the constructor.\n     *\n     * Will check if versions match and compare provided index configuration\n     * with existing ones, and update indexes if necessary.\n     *\n     * Will call this.onStoreReady() if everything went well and the store\n     * is ready to use, and this.onError() is something went wrong.\n     *\n     * @private\n     *\n     */\n    openDB: function () {\n      var openRequest = this.idb.open(this.dbName, this.dbVersion);\n      var preventSuccessCallback = false;\n      openRequest.onerror = function (errorEvent) {\n        if (hasVersionError(errorEvent)) {\n          this.onError(new Error('The version number provided is lower than the existing one.'));\n        } else {\n          var error;\n          if (errorEvent.target.error) {\n            error = errorEvent.target.error;\n          } else {\n            var errorMessage = 'IndexedDB unknown error occurred when opening DB ' + this.dbName + ' version ' + this.dbVersion;\n            if ('errorCode' in errorEvent.target) {\n              errorMessage += ' with error code ' + errorEvent.target.errorCode;\n            }\n            error = new Error(errorMessage);\n          }\n          this.onError(error);\n        }\n      }.bind(this);\n      openRequest.onsuccess = function (event) {\n        if (preventSuccessCallback) {\n          return;\n        }\n        if (this.db) {\n          this.onStoreReady();\n          return;\n        }\n        this.db = event.target.result;\n        if (typeof this.db.version == 'string') {\n          this.onError(new Error('The IndexedDB implementation in this browser is outdated. Please upgrade your browser.'));\n          return;\n        }\n        if (!this.db.objectStoreNames.contains(this.storeName)) {\n          // We should never ever get here.\n          // Lets notify the user anyway.\n          this.onError(new Error('Object store couldn\\'t be created.'));\n          return;\n        }\n        var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n        this.store = emptyTransaction.objectStore(this.storeName);\n\n        // check indexes\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function (indexData) {\n          var indexName = indexData.name;\n          if (!indexName) {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create index: No index name given.'));\n            return;\n          }\n          this.normalizeIndexData(indexData);\n          if (this.hasIndex(indexName)) {\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n            if (!complies) {\n              preventSuccessCallback = true;\n              this.onError(new Error('Cannot modify index \"' + indexName + '\" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));\n            }\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create new index \"' + indexName + '\" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));\n          }\n        }, this);\n        if (existingIndexes.length) {\n          preventSuccessCallback = true;\n          this.onError(new Error('Cannot delete index(es) \"' + existingIndexes.toString() + '\" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'));\n        }\n        preventSuccessCallback || this.onStoreReady();\n      }.bind(this);\n      openRequest.onupgradeneeded = function ( /* IDBVersionChangeEvent */event) {\n        this.db = event.target.result;\n        if (this.db.objectStoreNames.contains(this.storeName)) {\n          this.store = event.target.transaction.objectStore(this.storeName);\n        } else {\n          var optionalParameters = {\n            autoIncrement: this.autoIncrement\n          };\n          if (this.keyPath !== null) {\n            optionalParameters.keyPath = this.keyPath;\n          }\n          this.store = this.db.createObjectStore(this.storeName, optionalParameters);\n        }\n        var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n        this.indexes.forEach(function (indexData) {\n          var indexName = indexData.name;\n          if (!indexName) {\n            preventSuccessCallback = true;\n            this.onError(new Error('Cannot create index: No index name given.'));\n          }\n          this.normalizeIndexData(indexData);\n          if (this.hasIndex(indexName)) {\n            // check if it complies\n            var actualIndex = this.store.index(indexName);\n            var complies = this.indexComplies(actualIndex, indexData);\n            if (!complies) {\n              // index differs, need to delete and re-create\n              this.store.deleteIndex(indexName);\n              this.store.createIndex(indexName, indexData.keyPath, {\n                unique: indexData.unique,\n                multiEntry: indexData.multiEntry\n              });\n            }\n            existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n          } else {\n            this.store.createIndex(indexName, indexData.keyPath, {\n              unique: indexData.unique,\n              multiEntry: indexData.multiEntry\n            });\n          }\n        }, this);\n        if (existingIndexes.length) {\n          existingIndexes.forEach(function (_indexName) {\n            this.store.deleteIndex(_indexName);\n          }, this);\n        }\n      }.bind(this);\n    },\n    /**\n     * Deletes the database used for this store if the IDB implementations\n     * provides that functionality.\n     *\n     * @param {Function} [onSuccess] A callback that is called if deletion\n     *  was successful.\n     * @param {Function} [onError] A callback that is called if deletion\n     *  failed.\n     */\n    deleteDatabase: function (onSuccess, onError) {\n      if (this.idb.deleteDatabase) {\n        this.db.close();\n        var deleteRequest = this.idb.deleteDatabase(this.dbName);\n        deleteRequest.onsuccess = onSuccess;\n        deleteRequest.onerror = onError;\n      } else {\n        onError(new Error('Browser does not support IndexedDB deleteDatabase!'));\n      }\n    },\n    /*********************\n     * data manipulation *\n     *********************/\n\n    /**\n     * Puts an object into the store. If an entry with the given id exists,\n     * it will be overwritten. This method has a different signature for inline\n     * keys and out-of-line keys; please see the examples below.\n     *\n     * @param {*} [key] The key to store. This is only needed if IDBWrapper\n     *  is set to use out-of-line keys. For inline keys - the default scenario -\n     *  this can be omitted.\n     * @param {Object} value The data object to store.\n     * @param {Function} [onSuccess] A callback that is called if insertion\n     *  was successful.\n     * @param {Function} [onError] A callback that is called if insertion\n     *  failed.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n     // Storing an object, using inline keys (the default scenario):\n     var myCustomer = {\n         customerid: 2346223,\n         lastname: 'Doe',\n         firstname: 'John'\n     };\n     myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);\n     // Note that passing success- and error-handlers is optional.\n     * @example\n     // Storing an object, using out-of-line keys:\n     var myCustomer = {\n         lastname: 'Doe',\n         firstname: 'John'\n     };\n     myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);\n     // Note that passing success- and error-handlers is optional.\n     */\n    put: function (key, value, onSuccess, onError) {\n      if (this.keyPath !== null) {\n        onError = onSuccess;\n        onSuccess = value;\n        value = key;\n      }\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n        result = null,\n        putRequest;\n      var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      putTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      putTransaction.onabort = onError;\n      putTransaction.onerror = onError;\n      if (this.keyPath !== null) {\n        // in-line keys\n        this._addIdPropertyIfNeeded(value);\n        putRequest = putTransaction.objectStore(this.storeName).put(value);\n      } else {\n        // out-of-line keys\n        putRequest = putTransaction.objectStore(this.storeName).put(value, key);\n      }\n      putRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      putRequest.onerror = onError;\n      return putTransaction;\n    },\n    /**\n     * Retrieves an object from the store. If no entry exists with the given id,\n     * the success handler will be called with null as first and only argument.\n     *\n     * @param {*} key The id of the object to fetch.\n     * @param {Function} [onSuccess] A callback that is called if fetching\n     *  was successful. Will receive the object as only argument.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    get: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n        result = null;\n      var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      getTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getTransaction.onabort = onError;\n      getTransaction.onerror = onError;\n      var getRequest = getTransaction.objectStore(this.storeName).get(key);\n      getRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      getRequest.onerror = onError;\n      return getTransaction;\n    },\n    /**\n     * Removes an object from the store.\n     *\n     * @param {*} key The id of the object to remove.\n     * @param {Function} [onSuccess] A callback that is called if the removal\n     *  was successful.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    remove: function (key, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n        result = null;\n      var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      removeTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      removeTransaction.onabort = onError;\n      removeTransaction.onerror = onError;\n      var deleteRequest = removeTransaction.objectStore(this.storeName)['delete'](key);\n      deleteRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      deleteRequest.onerror = onError;\n      return removeTransaction;\n    },\n    /**\n     * Runs a batch of put and/or remove operations on the store.\n     *\n     * @param {Array} dataArray An array of objects containing the operation to run\n     *  and the data object (for put operations).\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    batch: function (dataArray, onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n        onError(new Error('dataArray argument must be of type Array.'));\n      } else if (dataArray.length === 0) {\n        return onSuccess(true);\n      }\n      var count = dataArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(hasSuccess);\n      };\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n      var onItemSuccess = function () {\n        count--;\n        if (count === 0 && !called) {\n          called = true;\n          hasSuccess = true;\n        }\n      };\n      dataArray.forEach(function (operation) {\n        var type = operation.type;\n        var key = operation.key;\n        var value = operation.value;\n        var onItemError = function (err) {\n          batchTransaction.abort();\n          if (!called) {\n            called = true;\n            onError(err, type, key);\n          }\n        };\n        if (type == 'remove') {\n          var deleteRequest = batchTransaction.objectStore(this.storeName)['delete'](key);\n          deleteRequest.onsuccess = onItemSuccess;\n          deleteRequest.onerror = onItemError;\n        } else if (type == 'put') {\n          var putRequest;\n          if (this.keyPath !== null) {\n            // in-line keys\n            this._addIdPropertyIfNeeded(value);\n            putRequest = batchTransaction.objectStore(this.storeName).put(value);\n          } else {\n            // out-of-line keys\n            putRequest = batchTransaction.objectStore(this.storeName).put(value, key);\n          }\n          putRequest.onsuccess = onItemSuccess;\n          putRequest.onerror = onItemError;\n        }\n      }, this);\n      return batchTransaction;\n    },\n    /**\n     * Takes an array of objects and stores them in a single transaction.\n     *\n     * @param {Array} dataArray An array of objects to store\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    putBatch: function (dataArray, onSuccess, onError) {\n      var batchData = dataArray.map(function (item) {\n        return {\n          type: 'put',\n          value: item\n        };\n      });\n      return this.batch(batchData, onSuccess, onError);\n    },\n    /**\n     * Like putBatch, takes an array of objects and stores them in a single\n     * transaction, but allows processing of the result values.  Returns the\n     * processed records containing the key for newly created records to the\n     * onSuccess calllback instead of only returning true or false for success.\n     * In addition, added the option for the caller to specify a key field that\n     * should be set to the newly created key.\n     *\n     * @param {Array} dataArray An array of objects to store\n     * @param {Object} [options] An object containing optional options\n     * @param {String} [options.keyField=this.keyPath] Specifies a field in the record to update\n     *  with the auto-incrementing key. Defaults to the store's keyPath.\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     *\n     */\n    upsertBatch: function (dataArray, options, onSuccess, onError) {\n      // handle `dataArray, onSuccess, onError` signature\n      if (typeof options == 'function') {\n        onSuccess = options;\n        onError = onSuccess;\n        options = {};\n      }\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      options || (options = {});\n      if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n        onError(new Error('dataArray argument must be of type Array.'));\n      }\n      var keyField = options.keyField || this.keyPath;\n      var count = dataArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var index = 0; // assume success callbacks are executed in order\n\n      var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      batchTransaction.oncomplete = function () {\n        if (hasSuccess) {\n          onSuccess(dataArray);\n        } else {\n          onError(false);\n        }\n      };\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n      var onItemSuccess = function (event) {\n        var record = dataArray[index++];\n        record[keyField] = event.target.result;\n        count--;\n        if (count === 0 && !called) {\n          called = true;\n          hasSuccess = true;\n        }\n      };\n      dataArray.forEach(function (record) {\n        var key = record.key;\n        var onItemError = function (err) {\n          batchTransaction.abort();\n          if (!called) {\n            called = true;\n            onError(err);\n          }\n        };\n        var putRequest;\n        if (this.keyPath !== null) {\n          // in-line keys\n          this._addIdPropertyIfNeeded(record);\n          putRequest = batchTransaction.objectStore(this.storeName).put(record);\n        } else {\n          // out-of-line keys\n          putRequest = batchTransaction.objectStore(this.storeName).put(record, key);\n        }\n        putRequest.onsuccess = onItemSuccess;\n        putRequest.onerror = onItemError;\n      }, this);\n      return batchTransaction;\n    },\n    /**\n     * Takes an array of keys and removes matching objects in a single\n     * transaction.\n     *\n     * @param {Array} keyArray An array of keys to remove\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    removeBatch: function (keyArray, onSuccess, onError) {\n      var batchData = keyArray.map(function (key) {\n        return {\n          type: 'remove',\n          key: key\n        };\n      });\n      return this.batch(batchData, onSuccess, onError);\n    },\n    /**\n     * Takes an array of keys and fetches matching objects\n     *\n     * @param {Array} keyArray An array of keys identifying the objects to fetch\n     * @param {Function} [onSuccess] A callback that is called if all operations\n     *  were successful.\n     * @param {Function} [onError] A callback that is called if an error\n     *  occurred during one of the operations.\n     * @param {String} [arrayType='sparse'] The type of array to pass to the\n     *  success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to\n     *  'sparse'. This parameter specifies how to handle the situation if a get\n     *  operation did not throw an error, but there was no matching object in\n     *  the database. In most cases, 'sparse' provides the most desired\n     *  behavior. See the examples for details.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     * @example\n     // given that there are two objects in the database with the keypath\n     // values 1 and 2, and the call looks like this:\n     myStore.getBatch([1, 5, 2], onError, function (data) { â€¦ }, arrayType);\n      // this is what the `data` array will be like:\n      // arrayType == 'sparse':\n     // data is a sparse array containing two entries and having a length of 3:\n     [Object, 2: Object]\n     0: Object\n     2: Object\n     length: 3\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter matching the index of the key in the\n     // keyArray.\n      // arrayType == 'dense':\n     // data is a dense array containing three entries and having a length of 3,\n     // where data[1] is of type undefined:\n     [Object, undefined, Object]\n     0: Object\n     1: undefined\n     2: Object\n     length: 3\n     // calling forEach on data will result in the callback being called three\n     // times, with the index parameter matching the index of the key in the\n     // keyArray, but the second call will have undefined as first argument.\n      // arrayType == 'skip':\n     // data is a dense array containing two entries and having a length of 2:\n     [Object, Object]\n     0: Object\n     1: Object\n     length: 2\n     // calling forEach on data will result in the callback being called two\n     // times, with the index parameter not matching the index of the key in the\n     // keyArray.\n     */\n    getBatch: function (keyArray, onSuccess, onError, arrayType) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      arrayType || (arrayType = 'sparse');\n      if (Object.prototype.toString.call(keyArray) != '[object Array]') {\n        onError(new Error('keyArray argument must be of type Array.'));\n      } else if (keyArray.length === 0) {\n        return onSuccess([]);\n      }\n      var data = [];\n      var count = keyArray.length;\n      var called = false;\n      var hasSuccess = false;\n      var result = null;\n      var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      batchTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      batchTransaction.onabort = onError;\n      batchTransaction.onerror = onError;\n      var onItemSuccess = function (event) {\n        if (event.target.result || arrayType == 'dense') {\n          data.push(event.target.result);\n        } else if (arrayType == 'sparse') {\n          data.length++;\n        }\n        count--;\n        if (count === 0) {\n          called = true;\n          hasSuccess = true;\n          result = data;\n        }\n      };\n      keyArray.forEach(function (key) {\n        var onItemError = function (err) {\n          called = true;\n          result = err;\n          onError(err);\n          batchTransaction.abort();\n        };\n        var getRequest = batchTransaction.objectStore(this.storeName).get(key);\n        getRequest.onsuccess = onItemSuccess;\n        getRequest.onerror = onItemError;\n      }, this);\n      return batchTransaction;\n    },\n    /**\n     * Fetches all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that is called if the operation\n     *  was successful. Will receive an array of objects.\n     * @param {Function} [onError] A callback that will be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    getAll: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      var store = getAllTransaction.objectStore(this.storeName);\n      if (store.getAll) {\n        this._getAllNative(getAllTransaction, store, onSuccess, onError);\n      } else {\n        this._getAllCursor(getAllTransaction, store, onSuccess, onError);\n      }\n      return getAllTransaction;\n    },\n    /**\n     * Implements getAll for IDB implementations that have a non-standard\n     * getAll() method.\n     *\n     * @param {IDBTransaction} getAllTransaction An open READ transaction.\n     * @param {IDBObjectStore} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllNative: function (getAllTransaction, store, onSuccess, onError) {\n      var hasSuccess = false,\n        result = null;\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n      var getAllRequest = store.getAll();\n      getAllRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      getAllRequest.onerror = onError;\n    },\n    /**\n     * Implements getAll for IDB implementations that do not have a getAll()\n     * method.\n     *\n     * @param {IDBTransaction} getAllTransaction An open READ transaction.\n     * @param {IDBObjectStore} store A reference to the store.\n     * @param {Function} onSuccess A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} onError A callback that will be called if an\n     *  error occurred during the operation.\n     * @private\n     */\n    _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {\n      var all = [],\n        hasSuccess = false,\n        result = null;\n      getAllTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      getAllTransaction.onabort = onError;\n      getAllTransaction.onerror = onError;\n      var cursorRequest = store.openCursor();\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          all.push(cursor.value);\n          cursor['continue']();\n        } else {\n          hasSuccess = true;\n          result = all;\n        }\n      };\n      cursorRequest.onError = onError;\n    },\n    /**\n     * Clears the store, i.e. deletes all entries in the store.\n     *\n     * @param {Function} [onSuccess] A callback that will be called if the\n     *  operation was successful.\n     * @param {Function} [onError] A callback that will be called if an\n     *  error occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    clear: function (onSuccess, onError) {\n      onError || (onError = defaultErrorHandler);\n      onSuccess || (onSuccess = defaultSuccessHandler);\n      var hasSuccess = false,\n        result = null;\n      var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n      clearTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      clearTransaction.onabort = onError;\n      clearTransaction.onerror = onError;\n      var clearRequest = clearTransaction.objectStore(this.storeName).clear();\n      clearRequest.onsuccess = function (event) {\n        hasSuccess = true;\n        result = event.target.result;\n      };\n      clearRequest.onerror = onError;\n      return clearTransaction;\n    },\n    /**\n     * Checks if an id property needs to present on a object and adds one if\n     * necessary.\n     *\n     * @param {Object} dataObj The data object that is about to be stored\n     * @private\n     */\n    _addIdPropertyIfNeeded: function (dataObj) {\n      if (typeof dataObj[this.keyPath] == 'undefined') {\n        dataObj[this.keyPath] = this._insertIdCount++ + Date.now();\n      }\n    },\n    /************\n     * indexing *\n     ************/\n\n    /**\n     * Returns a DOMStringList of index names of the store.\n     *\n     * @return {DOMStringList} The list of index names\n     */\n    getIndexList: function () {\n      return this.store.indexNames;\n    },\n    /**\n     * Checks if an index with the given name exists in the store.\n     *\n     * @param {String} indexName The name of the index to look for\n     * @return {Boolean} Whether the store contains an index with the given name\n     */\n    hasIndex: function (indexName) {\n      return this.store.indexNames.contains(indexName);\n    },\n    /**\n     * Normalizes an object containing index data and assures that all\n     * properties are set.\n     *\n     * @param {Object} indexData The index data object to normalize\n     * @param {String} indexData.name The name of the index\n     * @param {String} [indexData.keyPath] The key path of the index\n     * @param {Boolean} [indexData.unique] Whether the index is unique\n     * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry\n     */\n    normalizeIndexData: function (indexData) {\n      indexData.keyPath = indexData.keyPath || indexData.name;\n      indexData.unique = !!indexData.unique;\n      indexData.multiEntry = !!indexData.multiEntry;\n    },\n    /**\n     * Checks if an actual index complies with an expected index.\n     *\n     * @param {IDBIndex} actual The actual index found in the store\n     * @param {Object} expected An Object describing an expected index\n     * @return {Boolean} Whether both index definitions are identical\n     */\n    indexComplies: function (actual, expected) {\n      var complies = ['keyPath', 'unique', 'multiEntry'].every(function (key) {\n        // IE10 returns undefined for no multiEntry\n        if (key == 'multiEntry' && actual[key] === undefined && expected[key] === false) {\n          return true;\n        }\n        // Compound keys\n        if (key == 'keyPath' && Object.prototype.toString.call(expected[key]) == '[object Array]') {\n          var exp = expected.keyPath;\n          var act = actual.keyPath;\n\n          // IE10 can't handle keyPath sequences and stores them as a string.\n          // The index will be unusable there, but let's still return true if\n          // the keyPath sequence matches.\n          if (typeof act == 'string') {\n            return exp.toString() == act;\n          }\n\n          // Chrome/Opera stores keyPath squences as DOMStringList, Firefox\n          // as Array\n          if (!(typeof act.contains == 'function' || typeof act.indexOf == 'function')) {\n            return false;\n          }\n          if (act.length !== exp.length) {\n            return false;\n          }\n          for (var i = 0, m = exp.length; i < m; i++) {\n            if (!(act.contains && act.contains(exp[i]) || act.indexOf(exp[i] !== -1))) {\n              return false;\n            }\n          }\n          return true;\n        }\n        return expected[key] == actual[key];\n      });\n      return complies;\n    },\n    /**********\n     * cursor *\n     **********/\n\n    /**\n     * Iterates over the store using the given options and calling onItem\n     * for each entry matching the options.\n     *\n     * @param {Function} onItem A callback to be called for each match\n     * @param {Object} [options] An object defining specific options\n     * @param {String} [options.index=null] A name of an IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.autoContinue=true] Whether to automatically\n     *  iterate the cursor to the next result\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Boolean} [options.writeAccess=false] Whether grant write access\n     *  to the store in the onItem callback\n     * @param {Function} [options.onEnd=null] A callback to be called after\n     *  iteration has ended\n     * @param {Function} [options.onError=throw] A callback to be called\n     *  if an error occurred during the operation.\n     * @param {Number} [options.limit=Infinity] Limit the number of returned\n     *  results to this number\n     * @param {Number} [options.offset=0] Skip the provided number of results\n     *  in the resultset\n     * @param {Boolean} [options.allowItemRejection=false] Allows the onItem\n     * function to return a Boolean to accept or reject the current item\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    iterate: function (onItem, options) {\n      options = mixin({\n        index: null,\n        order: 'ASC',\n        autoContinue: true,\n        filterDuplicates: false,\n        keyRange: null,\n        writeAccess: false,\n        onEnd: null,\n        onError: defaultErrorHandler,\n        limit: Infinity,\n        offset: 0,\n        allowItemRejection: false\n      }, options || {});\n      var directionType = options.order.toLowerCase() == 'desc' ? 'PREV' : 'NEXT';\n      if (options.filterDuplicates) {\n        directionType += '_NO_DUPLICATE';\n      }\n      var hasSuccess = false;\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? 'READ_WRITE' : 'READ_ONLY']);\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n      var recordCount = 0;\n      cursorTransaction.oncomplete = function () {\n        if (!hasSuccess) {\n          options.onError(null);\n          return;\n        }\n        if (options.onEnd) {\n          options.onEnd();\n        } else {\n          onItem(null);\n        }\n      };\n      cursorTransaction.onabort = options.onError;\n      cursorTransaction.onerror = options.onError;\n      var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);\n      cursorRequest.onerror = options.onError;\n      cursorRequest.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          if (options.offset) {\n            cursor.advance(options.offset);\n            options.offset = 0;\n          } else {\n            var onItemReturn = onItem(cursor.value, cursor, cursorTransaction);\n            if (!options.allowItemRejection || onItemReturn !== false) {\n              recordCount++;\n            }\n            if (options.autoContinue) {\n              if (recordCount + options.offset < options.limit) {\n                cursor['continue']();\n              } else {\n                hasSuccess = true;\n              }\n            }\n          }\n        } else {\n          hasSuccess = true;\n        }\n      };\n      return cursorTransaction;\n    },\n    /**\n     * Runs a query against the store and passes an array containing matched\n     * objects to the success handler.\n     *\n     * @param {Function} onSuccess A callback to be called when the operation\n     *  was successful.\n     * @param {Object} [options] An object defining specific options\n     * @param {String} [options.index=null] A name of an IDBIndex to operate on\n     * @param {String} [options.order=ASC] The order in which to provide the\n     *  results, can be 'DESC' or 'ASC'\n     * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n     *  duplicate matches\n     * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called\n     *  if an error occurred during the operation.\n     * @param {Number} [options.limit=Infinity] Limit the number of returned\n     *  results to this number\n     * @param {Number} [options.offset=0] Skip the provided number of results\n     *  in the resultset\n     * @param {Function} [options.filter=null] A custom filter function to\n     *  apply to query resuts before returning. Must return `false` to reject\n     *  an item. Can be combined with keyRanges.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    query: function (onSuccess, options) {\n      var result = [],\n        processedItems = 0;\n      options = options || {};\n      options.autoContinue = true;\n      options.writeAccess = false;\n      options.allowItemRejection = !!options.filter;\n      options.onEnd = function () {\n        onSuccess(result, processedItems);\n      };\n      return this.iterate(function (item) {\n        processedItems++;\n        var accept = options.filter ? options.filter(item) : true;\n        if (accept !== false) {\n          result.push(item);\n        }\n        return accept;\n      }, options);\n    },\n    /**\n     *\n     * Runs a query against the store, but only returns the number of matches\n     * instead of the matches itself.\n     *\n     * @param {Function} onSuccess A callback to be called if the opration\n     *  was successful.\n     * @param {Object} [options] An object defining specific options\n     * @param {String} [options.index=null] A name of an IDBIndex to operate on\n     * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n     * @param {Function} [options.onError=throw] A callback to be called if an error\n     *  occurred during the operation.\n     * @returns {IDBTransaction} The transaction used for this operation.\n     */\n    count: function (onSuccess, options) {\n      options = mixin({\n        index: null,\n        keyRange: null\n      }, options || {});\n      var onError = options.onError || defaultErrorHandler;\n      var hasSuccess = false,\n        result = null;\n      var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n      cursorTransaction.oncomplete = function () {\n        var callback = hasSuccess ? onSuccess : onError;\n        callback(result);\n      };\n      cursorTransaction.onabort = onError;\n      cursorTransaction.onerror = onError;\n      var cursorTarget = cursorTransaction.objectStore(this.storeName);\n      if (options.index) {\n        cursorTarget = cursorTarget.index(options.index);\n      }\n      var countRequest = cursorTarget.count(options.keyRange);\n      countRequest.onsuccess = function (evt) {\n        hasSuccess = true;\n        result = evt.target.result;\n      };\n      countRequest.onError = onError;\n      return cursorTransaction;\n    },\n    /**************/\n    /* key ranges */\n    /**************/\n\n    /**\n     * Creates a key range using specified options. This key range can be\n     * handed over to the count() and iterate() methods.\n     *\n     * Note: You must provide at least one or both of \"lower\" or \"upper\" value.\n     *\n     * @param {Object} options The options for the key range to create\n     * @param {*} [options.lower] The lower bound\n     * @param {Boolean} [options.excludeLower] Whether to exclude the lower\n     *  bound passed in options.lower from the key range\n     * @param {*} [options.upper] The upper bound\n     * @param {Boolean} [options.excludeUpper] Whether to exclude the upper\n     *  bound passed in options.upper from the key range\n     * @param {*} [options.only] A single key value. Use this if you need a key\n     *  range that only includes one value for a key. Providing this\n     *  property invalidates all other properties.\n     * @return {IDBKeyRange} The IDBKeyRange representing the specified options\n     */\n    makeKeyRange: function (options) {\n      /*jshint onecase:true */\n      var keyRange,\n        hasLower = typeof options.lower != 'undefined',\n        hasUpper = typeof options.upper != 'undefined',\n        isOnly = typeof options.only != 'undefined';\n      switch (true) {\n        case isOnly:\n          keyRange = this.keyRange.only(options.only);\n          break;\n        case hasLower && hasUpper:\n          keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);\n          break;\n        case hasLower:\n          keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);\n          break;\n        case hasUpper:\n          keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);\n          break;\n        default:\n          throw new Error('Cannot create KeyRange. Provide one or both of \"lower\" or \"upper\" value, or an \"only\" value.');\n      }\n      return keyRange;\n    }\n  };\n\n  /** helpers **/\n  var empty = {};\n  function mixin(target, source) {\n    var name, s;\n    for (name in source) {\n      s = source[name];\n      if (s !== empty[name] && s !== target[name]) {\n        target[name] = s;\n      }\n    }\n    return target;\n  }\n  function hasVersionError(errorEvent) {\n    if ('error' in errorEvent.target) {\n      return errorEvent.target.error.name == 'VersionError';\n    } else if ('errorCode' in errorEvent.target) {\n      return errorEvent.target.errorCode == 12;\n    }\n    return false;\n  }\n  IDBStore.prototype = proto;\n  IDBStore.version = proto.version;\n  return IDBStore;\n}, this);","map":{"version":3,"names":["name","definition","global","define","module","exports","defaultErrorHandler","error","defaultSuccessHandler","defaults","storeName","storePrefix","dbVersion","keyPath","autoIncrement","onStoreReady","onError","indexes","implementationPreference","IDBStore","kwArgs","Object","prototype","toString","call","key","dbName","parseInt","env","window","self","availableImplementations","filter","implName","implementation","idb","keyRange","IDBKeyRange","webkitIDBKeyRange","mozIDBKeyRange","consts","openDB","proto","constructor","version","db","store","_insertIdCount","openRequest","open","preventSuccessCallback","onerror","errorEvent","hasVersionError","Error","target","errorMessage","errorCode","bind","onsuccess","event","result","objectStoreNames","contains","emptyTransaction","transaction","READ_ONLY","objectStore","existingIndexes","Array","slice","getIndexList","forEach","indexData","indexName","normalizeIndexData","hasIndex","actualIndex","index","complies","indexComplies","splice","indexOf","length","onupgradeneeded","optionalParameters","createObjectStore","deleteIndex","createIndex","unique","multiEntry","_indexName","deleteDatabase","onSuccess","close","deleteRequest","put","value","hasSuccess","putRequest","putTransaction","READ_WRITE","oncomplete","callback","onabort","_addIdPropertyIfNeeded","get","getTransaction","getRequest","remove","removeTransaction","batch","dataArray","count","called","batchTransaction","onItemSuccess","operation","type","onItemError","err","abort","putBatch","batchData","map","item","upsertBatch","options","keyField","record","removeBatch","keyArray","getBatch","arrayType","data","push","getAll","getAllTransaction","_getAllNative","_getAllCursor","getAllRequest","all","cursorRequest","openCursor","cursor","clear","clearTransaction","clearRequest","dataObj","Date","now","indexNames","actual","expected","every","undefined","exp","act","i","m","iterate","onItem","mixin","order","autoContinue","filterDuplicates","writeAccess","onEnd","limit","Infinity","offset","allowItemRejection","directionType","toLowerCase","cursorTransaction","cursorTarget","recordCount","advance","onItemReturn","query","processedItems","accept","countRequest","evt","makeKeyRange","hasLower","lower","hasUpper","upper","isOnly","only","bound","excludeLower","excludeUpper","lowerBound","upperBound","empty","source","s"],"sources":["C:/Users/Moran/Documents/react-projects/react-demo/node_modules/idb-wrapper/idbstore.js"],"sourcesContent":["/*global window:false, self:false, define:false, module:false */\n\n/**\n * @license IDBWrapper - A cross-browser wrapper for IndexedDB\n * Version 1.7.2\n * Copyright (c) 2011 - 2017 Jens Arps\n * http://jensarps.de/\n *\n * Licensed under the MIT license\n */\n\n(function (name, definition, global) {\n\n    'use strict';\n\n    if (typeof define === 'function') {\n        define(definition);\n    } else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = definition();\n    } else {\n        global[name] = definition();\n    }\n})('IDBStore', function () {\n\n    'use strict';\n\n    var defaultErrorHandler = function (error) {\n        throw error;\n    };\n    var defaultSuccessHandler = function () {\n    };\n\n    var defaults = {\n        storeName: 'Store',\n        storePrefix: 'IDBWrapper-',\n        dbVersion: 1,\n        keyPath: 'id',\n        autoIncrement: true,\n        onStoreReady: function () {\n        },\n        onError: defaultErrorHandler,\n        indexes: [],\n        implementationPreference: [\n            'indexedDB',\n            'webkitIndexedDB',\n            'mozIndexedDB',\n            'shimIndexedDB'\n        ]\n    };\n\n    /**\n     *\n     * The IDBStore constructor\n     *\n     * @constructor\n     * @name IDBStore\n     * @version 1.7.2\n     *\n     * @param {Object} [kwArgs] An options object used to configure the store and\n     *  set callbacks\n     * @param {String} [kwArgs.storeName='Store'] The name of the store\n     * @param {String} [kwArgs.storePrefix='IDBWrapper-'] A prefix that is\n     *  internally used to construct the name of the database, which will be\n     *  kwArgs.storePrefix + kwArgs.storeName\n     * @param {Number} [kwArgs.dbVersion=1] The version of the store\n     * @param {String} [kwArgs.keyPath='id'] The key path to use. If you want to\n     *  setup IDBWrapper to work with out-of-line keys, you need to set this to\n     *  `null`\n     * @param {Boolean} [kwArgs.autoIncrement=true] If set to true, IDBStore will\n     *  automatically make sure a unique keyPath value is present on each object\n     *  that is stored.\n     * @param {Function} [kwArgs.onStoreReady] A callback to be called when the\n     *  store is ready to be used.\n     * @param {Function} [kwArgs.onError=throw] A callback to be called when an\n     *  error occurred during instantiation of the store.\n     * @param {Array} [kwArgs.indexes=[]] An array of indexData objects\n     *  defining the indexes to use with the store. For every index to be used\n     *  one indexData object needs to be passed in the array.\n     *  An indexData object is defined as follows:\n     * @param {Object} [kwArgs.indexes.indexData] An object defining the index to\n     *  use\n     * @param {String} kwArgs.indexes.indexData.name The name of the index\n     * @param {String} [kwArgs.indexes.indexData.keyPath] The key path of the index\n     * @param {Boolean} [kwArgs.indexes.indexData.unique] Whether the index is unique\n     * @param {Boolean} [kwArgs.indexes.indexData.multiEntry] Whether the index is multi entry\n     * @param {Array} [kwArgs.implementationPreference=['indexedDB','webkitIndexedDB','mozIndexedDB','shimIndexedDB']] An array of strings naming implementations to be used, in order or preference\n     * @param {Function} [onStoreReady] A callback to be called when the store\n     * is ready to be used.\n     * @example\n     // create a store for customers with an additional index over the\n     // `lastname` property.\n     var myCustomerStore = new IDBStore({\n         dbVersion: 1,\n         storeName: 'customer-index',\n         keyPath: 'customerid',\n         autoIncrement: true,\n         onStoreReady: populateTable,\n         indexes: [\n             { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }\n         ]\n     });\n     * @example\n     // create a generic store\n     var myCustomerStore = new IDBStore({\n         storeName: 'my-data-store',\n         onStoreReady: function(){\n             // start working with the store.\n         }\n     });\n     */\n    var IDBStore = function (kwArgs, onStoreReady) {\n\n        if (typeof onStoreReady == 'undefined' && typeof kwArgs == 'function') {\n            onStoreReady = kwArgs;\n        }\n        if (Object.prototype.toString.call(kwArgs) != '[object Object]') {\n            kwArgs = {};\n        }\n\n        for (var key in defaults) {\n            this[key] = typeof kwArgs[key] != 'undefined' ? kwArgs[key] : defaults[key];\n        }\n\n        this.dbName = this.storePrefix + this.storeName;\n        this.dbVersion = parseInt(this.dbVersion, 10) || 1;\n\n        onStoreReady && (this.onStoreReady = onStoreReady);\n\n        var env = typeof window == 'object' ? window : self;\n        var availableImplementations = this.implementationPreference.filter(function (implName) {\n            return implName in env;\n        });\n        this.implementation = availableImplementations[0];\n        this.idb = env[this.implementation];\n        this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;\n\n        this.consts = {\n            'READ_ONLY': 'readonly',\n            'READ_WRITE': 'readwrite',\n            'VERSION_CHANGE': 'versionchange',\n            'NEXT': 'next',\n            'NEXT_NO_DUPLICATE': 'nextunique',\n            'PREV': 'prev',\n            'PREV_NO_DUPLICATE': 'prevunique'\n        };\n\n        this.openDB();\n    };\n\n    /** @lends IDBStore.prototype */\n    var proto = {\n\n        /**\n         * A pointer to the IDBStore ctor\n         *\n         * @private\n         * @type {Function}\n         * @constructs\n         */\n        constructor: IDBStore,\n\n        /**\n         * The version of IDBStore\n         *\n         * @type {String}\n         */\n        version: '1.7.2',\n\n        /**\n         * A reference to the IndexedDB object\n         *\n         * @type {IDBDatabase}\n         */\n        db: null,\n\n        /**\n         * The full name of the IndexedDB used by IDBStore, composed of\n         * this.storePrefix + this.storeName\n         *\n         * @type {String}\n         */\n        dbName: null,\n\n        /**\n         * The version of the IndexedDB used by IDBStore\n         *\n         * @type {Number}\n         */\n        dbVersion: null,\n\n        /**\n         * A reference to the objectStore used by IDBStore\n         *\n         * @type {IDBObjectStore}\n         */\n        store: null,\n\n        /**\n         * The store name\n         *\n         * @type {String}\n         */\n        storeName: null,\n\n        /**\n         * The prefix to prepend to the store name\n         *\n         * @type {String}\n         */\n        storePrefix: null,\n\n        /**\n         * The key path\n         *\n         * @type {String}\n         */\n        keyPath: null,\n\n        /**\n         * Whether IDBStore uses autoIncrement\n         *\n         * @type {Boolean}\n         */\n        autoIncrement: null,\n\n        /**\n         * The indexes used by IDBStore\n         *\n         * @type {Array}\n         */\n        indexes: null,\n\n        /**\n         * The implemantations to try to use, in order of preference\n         *\n         * @type {Array}\n         */\n        implementationPreference: null,\n\n        /**\n         * The actual implementation being used\n         *\n         * @type {String}\n         */\n        implementation: '',\n\n        /**\n         * The callback to be called when the store is ready to be used\n         *\n         * @type {Function}\n         */\n        onStoreReady: null,\n\n        /**\n         * The callback to be called if an error occurred during instantiation\n         * of the store\n         *\n         * @type {Function}\n         */\n        onError: null,\n\n        /**\n         * The internal insertID counter\n         *\n         * @type {Number}\n         * @private\n         */\n        _insertIdCount: 0,\n\n        /**\n         * Opens an IndexedDB; called by the constructor.\n         *\n         * Will check if versions match and compare provided index configuration\n         * with existing ones, and update indexes if necessary.\n         *\n         * Will call this.onStoreReady() if everything went well and the store\n         * is ready to use, and this.onError() is something went wrong.\n         *\n         * @private\n         *\n         */\n        openDB: function () {\n\n            var openRequest = this.idb.open(this.dbName, this.dbVersion);\n            var preventSuccessCallback = false;\n\n            openRequest.onerror = function (errorEvent) {\n\n                if (hasVersionError(errorEvent)) {\n                    this.onError(new Error('The version number provided is lower than the existing one.'));\n                } else {\n                    var error;\n\n                    if (errorEvent.target.error) {\n                        error = errorEvent.target.error;\n                    } else {\n                        var errorMessage = 'IndexedDB unknown error occurred when opening DB ' + this.dbName + ' version ' + this.dbVersion;\n                        if ('errorCode' in errorEvent.target) {\n                            errorMessage += ' with error code ' + errorEvent.target.errorCode;\n                        }\n                        error = new Error(errorMessage);\n                    }\n\n                    this.onError(error);\n                }\n            }.bind(this);\n\n            openRequest.onsuccess = function (event) {\n\n                if (preventSuccessCallback) {\n                    return;\n                }\n\n                if (this.db) {\n                    this.onStoreReady();\n                    return;\n                }\n\n                this.db = event.target.result;\n\n                if (typeof this.db.version == 'string') {\n                    this.onError(new Error('The IndexedDB implementation in this browser is outdated. Please upgrade your browser.'));\n                    return;\n                }\n\n                if (!this.db.objectStoreNames.contains(this.storeName)) {\n                    // We should never ever get here.\n                    // Lets notify the user anyway.\n                    this.onError(new Error('Object store couldn\\'t be created.'));\n                    return;\n                }\n\n                var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n                this.store = emptyTransaction.objectStore(this.storeName);\n\n                // check indexes\n                var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n                this.indexes.forEach(function (indexData) {\n                    var indexName = indexData.name;\n\n                    if (!indexName) {\n                        preventSuccessCallback = true;\n                        this.onError(new Error('Cannot create index: No index name given.'));\n                        return;\n                    }\n\n                    this.normalizeIndexData(indexData);\n\n                    if (this.hasIndex(indexName)) {\n                        // check if it complies\n                        var actualIndex = this.store.index(indexName);\n                        var complies = this.indexComplies(actualIndex, indexData);\n                        if (!complies) {\n                            preventSuccessCallback = true;\n                            this.onError(new Error('Cannot modify index \"' + indexName + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n                        }\n\n                        existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n                    } else {\n                        preventSuccessCallback = true;\n                        this.onError(new Error('Cannot create new index \"' + indexName + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n                    }\n\n                }, this);\n\n                if (existingIndexes.length) {\n                    preventSuccessCallback = true;\n                    this.onError(new Error('Cannot delete index(es) \"' + existingIndexes.toString() + '\" for current version. Please bump version number to ' + ( this.dbVersion + 1 ) + '.'));\n                }\n\n                preventSuccessCallback || this.onStoreReady();\n            }.bind(this);\n\n            openRequest.onupgradeneeded = function (/* IDBVersionChangeEvent */ event) {\n\n                this.db = event.target.result;\n\n                if (this.db.objectStoreNames.contains(this.storeName)) {\n                    this.store = event.target.transaction.objectStore(this.storeName);\n                } else {\n                    var optionalParameters = {autoIncrement: this.autoIncrement};\n                    if (this.keyPath !== null) {\n                        optionalParameters.keyPath = this.keyPath;\n                    }\n                    this.store = this.db.createObjectStore(this.storeName, optionalParameters);\n                }\n\n                var existingIndexes = Array.prototype.slice.call(this.getIndexList());\n                this.indexes.forEach(function (indexData) {\n                    var indexName = indexData.name;\n\n                    if (!indexName) {\n                        preventSuccessCallback = true;\n                        this.onError(new Error('Cannot create index: No index name given.'));\n                    }\n\n                    this.normalizeIndexData(indexData);\n\n                    if (this.hasIndex(indexName)) {\n                        // check if it complies\n                        var actualIndex = this.store.index(indexName);\n                        var complies = this.indexComplies(actualIndex, indexData);\n                        if (!complies) {\n                            // index differs, need to delete and re-create\n                            this.store.deleteIndex(indexName);\n                            this.store.createIndex(indexName, indexData.keyPath, {\n                                unique: indexData.unique,\n                                multiEntry: indexData.multiEntry\n                            });\n                        }\n\n                        existingIndexes.splice(existingIndexes.indexOf(indexName), 1);\n                    } else {\n                        this.store.createIndex(indexName, indexData.keyPath, {\n                            unique: indexData.unique,\n                            multiEntry: indexData.multiEntry\n                        });\n                    }\n\n                }, this);\n\n                if (existingIndexes.length) {\n                    existingIndexes.forEach(function (_indexName) {\n                        this.store.deleteIndex(_indexName);\n                    }, this);\n                }\n\n            }.bind(this);\n        },\n\n        /**\n         * Deletes the database used for this store if the IDB implementations\n         * provides that functionality.\n         *\n         * @param {Function} [onSuccess] A callback that is called if deletion\n         *  was successful.\n         * @param {Function} [onError] A callback that is called if deletion\n         *  failed.\n         */\n        deleteDatabase: function (onSuccess, onError) {\n            if (this.idb.deleteDatabase) {\n                this.db.close();\n                var deleteRequest = this.idb.deleteDatabase(this.dbName);\n                deleteRequest.onsuccess = onSuccess;\n                deleteRequest.onerror = onError;\n            } else {\n                onError(new Error('Browser does not support IndexedDB deleteDatabase!'));\n            }\n        },\n\n        /*********************\n         * data manipulation *\n         *********************/\n\n        /**\n         * Puts an object into the store. If an entry with the given id exists,\n         * it will be overwritten. This method has a different signature for inline\n         * keys and out-of-line keys; please see the examples below.\n         *\n         * @param {*} [key] The key to store. This is only needed if IDBWrapper\n         *  is set to use out-of-line keys. For inline keys - the default scenario -\n         *  this can be omitted.\n         * @param {Object} value The data object to store.\n         * @param {Function} [onSuccess] A callback that is called if insertion\n         *  was successful.\n         * @param {Function} [onError] A callback that is called if insertion\n         *  failed.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         * @example\n         // Storing an object, using inline keys (the default scenario):\n         var myCustomer = {\n             customerid: 2346223,\n             lastname: 'Doe',\n             firstname: 'John'\n         };\n         myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);\n         // Note that passing success- and error-handlers is optional.\n         * @example\n         // Storing an object, using out-of-line keys:\n         var myCustomer = {\n             lastname: 'Doe',\n             firstname: 'John'\n         };\n         myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);\n         // Note that passing success- and error-handlers is optional.\n         */\n        put: function (key, value, onSuccess, onError) {\n            if (this.keyPath !== null) {\n                onError = onSuccess;\n                onSuccess = value;\n                value = key;\n            }\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null,\n                putRequest;\n\n            var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            putTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            putTransaction.onabort = onError;\n            putTransaction.onerror = onError;\n\n            if (this.keyPath !== null) { // in-line keys\n                this._addIdPropertyIfNeeded(value);\n                putRequest = putTransaction.objectStore(this.storeName).put(value);\n            } else { // out-of-line keys\n                putRequest = putTransaction.objectStore(this.storeName).put(value, key);\n            }\n            putRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            putRequest.onerror = onError;\n\n            return putTransaction;\n        },\n\n        /**\n         * Retrieves an object from the store. If no entry exists with the given id,\n         * the success handler will be called with null as first and only argument.\n         *\n         * @param {*} key The id of the object to fetch.\n         * @param {Function} [onSuccess] A callback that is called if fetching\n         *  was successful. Will receive the object as only argument.\n         * @param {Function} [onError] A callback that will be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        get: function (key, onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null;\n\n            var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            getTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            getTransaction.onabort = onError;\n            getTransaction.onerror = onError;\n            var getRequest = getTransaction.objectStore(this.storeName).get(key);\n            getRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            getRequest.onerror = onError;\n\n            return getTransaction;\n        },\n\n        /**\n         * Removes an object from the store.\n         *\n         * @param {*} key The id of the object to remove.\n         * @param {Function} [onSuccess] A callback that is called if the removal\n         *  was successful.\n         * @param {Function} [onError] A callback that will be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        remove: function (key, onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null;\n\n            var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            removeTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            removeTransaction.onabort = onError;\n            removeTransaction.onerror = onError;\n\n            var deleteRequest = removeTransaction.objectStore(this.storeName)['delete'](key);\n            deleteRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            deleteRequest.onerror = onError;\n\n            return removeTransaction;\n        },\n\n        /**\n         * Runs a batch of put and/or remove operations on the store.\n         *\n         * @param {Array} dataArray An array of objects containing the operation to run\n         *  and the data object (for put operations).\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        batch: function (dataArray, onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n                onError(new Error('dataArray argument must be of type Array.'));\n            } else if (dataArray.length === 0) {\n                return onSuccess(true);\n            }\n\n            var count = dataArray.length;\n            var called = false;\n            var hasSuccess = false;\n\n            var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            batchTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(hasSuccess);\n            };\n            batchTransaction.onabort = onError;\n            batchTransaction.onerror = onError;\n\n\n            var onItemSuccess = function () {\n                count--;\n                if (count === 0 && !called) {\n                    called = true;\n                    hasSuccess = true;\n                }\n            };\n\n            dataArray.forEach(function (operation) {\n                var type = operation.type;\n                var key = operation.key;\n                var value = operation.value;\n\n                var onItemError = function (err) {\n                    batchTransaction.abort();\n                    if (!called) {\n                        called = true;\n                        onError(err, type, key);\n                    }\n                };\n\n                if (type == 'remove') {\n                    var deleteRequest = batchTransaction.objectStore(this.storeName)['delete'](key);\n                    deleteRequest.onsuccess = onItemSuccess;\n                    deleteRequest.onerror = onItemError;\n                } else if (type == 'put') {\n                    var putRequest;\n                    if (this.keyPath !== null) { // in-line keys\n                        this._addIdPropertyIfNeeded(value);\n                        putRequest = batchTransaction.objectStore(this.storeName).put(value);\n                    } else { // out-of-line keys\n                        putRequest = batchTransaction.objectStore(this.storeName).put(value, key);\n                    }\n                    putRequest.onsuccess = onItemSuccess;\n                    putRequest.onerror = onItemError;\n                }\n            }, this);\n\n            return batchTransaction;\n        },\n\n        /**\n         * Takes an array of objects and stores them in a single transaction.\n         *\n         * @param {Array} dataArray An array of objects to store\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        putBatch: function (dataArray, onSuccess, onError) {\n            var batchData = dataArray.map(function (item) {\n                return {type: 'put', value: item};\n            });\n\n            return this.batch(batchData, onSuccess, onError);\n        },\n\n        /**\n         * Like putBatch, takes an array of objects and stores them in a single\n         * transaction, but allows processing of the result values.  Returns the\n         * processed records containing the key for newly created records to the\n         * onSuccess calllback instead of only returning true or false for success.\n         * In addition, added the option for the caller to specify a key field that\n         * should be set to the newly created key.\n         *\n         * @param {Array} dataArray An array of objects to store\n         * @param {Object} [options] An object containing optional options\n         * @param {String} [options.keyField=this.keyPath] Specifies a field in the record to update\n         *  with the auto-incrementing key. Defaults to the store's keyPath.\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         *\n         */\n        upsertBatch: function (dataArray, options, onSuccess, onError) {\n            // handle `dataArray, onSuccess, onError` signature\n            if (typeof options == 'function') {\n                onSuccess = options;\n                onError = onSuccess;\n                options = {};\n            }\n\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n            options || (options = {});\n\n            if (Object.prototype.toString.call(dataArray) != '[object Array]') {\n                onError(new Error('dataArray argument must be of type Array.'));\n            }\n\n            var keyField = options.keyField || this.keyPath;\n            var count = dataArray.length;\n            var called = false;\n            var hasSuccess = false;\n            var index = 0; // assume success callbacks are executed in order\n\n            var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            batchTransaction.oncomplete = function () {\n                if (hasSuccess) {\n                    onSuccess(dataArray);\n                } else {\n                    onError(false);\n                }\n            };\n            batchTransaction.onabort = onError;\n            batchTransaction.onerror = onError;\n\n            var onItemSuccess = function (event) {\n                var record = dataArray[index++];\n                record[keyField] = event.target.result;\n\n                count--;\n                if (count === 0 && !called) {\n                    called = true;\n                    hasSuccess = true;\n                }\n            };\n\n            dataArray.forEach(function (record) {\n                var key = record.key;\n\n                var onItemError = function (err) {\n                    batchTransaction.abort();\n                    if (!called) {\n                        called = true;\n                        onError(err);\n                    }\n                };\n\n                var putRequest;\n                if (this.keyPath !== null) { // in-line keys\n                    this._addIdPropertyIfNeeded(record);\n                    putRequest = batchTransaction.objectStore(this.storeName).put(record);\n                } else { // out-of-line keys\n                    putRequest = batchTransaction.objectStore(this.storeName).put(record, key);\n                }\n                putRequest.onsuccess = onItemSuccess;\n                putRequest.onerror = onItemError;\n            }, this);\n\n            return batchTransaction;\n        },\n\n        /**\n         * Takes an array of keys and removes matching objects in a single\n         * transaction.\n         *\n         * @param {Array} keyArray An array of keys to remove\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        removeBatch: function (keyArray, onSuccess, onError) {\n            var batchData = keyArray.map(function (key) {\n                return {type: 'remove', key: key};\n            });\n\n            return this.batch(batchData, onSuccess, onError);\n        },\n\n        /**\n         * Takes an array of keys and fetches matching objects\n         *\n         * @param {Array} keyArray An array of keys identifying the objects to fetch\n         * @param {Function} [onSuccess] A callback that is called if all operations\n         *  were successful.\n         * @param {Function} [onError] A callback that is called if an error\n         *  occurred during one of the operations.\n         * @param {String} [arrayType='sparse'] The type of array to pass to the\n         *  success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to\n         *  'sparse'. This parameter specifies how to handle the situation if a get\n         *  operation did not throw an error, but there was no matching object in\n         *  the database. In most cases, 'sparse' provides the most desired\n         *  behavior. See the examples for details.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         * @example\n         // given that there are two objects in the database with the keypath\n         // values 1 and 2, and the call looks like this:\n         myStore.getBatch([1, 5, 2], onError, function (data) { â€¦ }, arrayType);\n\n         // this is what the `data` array will be like:\n\n         // arrayType == 'sparse':\n         // data is a sparse array containing two entries and having a length of 3:\n         [Object, 2: Object]\n         0: Object\n         2: Object\n         length: 3\n         // calling forEach on data will result in the callback being called two\n         // times, with the index parameter matching the index of the key in the\n         // keyArray.\n\n         // arrayType == 'dense':\n         // data is a dense array containing three entries and having a length of 3,\n         // where data[1] is of type undefined:\n         [Object, undefined, Object]\n         0: Object\n         1: undefined\n         2: Object\n         length: 3\n         // calling forEach on data will result in the callback being called three\n         // times, with the index parameter matching the index of the key in the\n         // keyArray, but the second call will have undefined as first argument.\n\n         // arrayType == 'skip':\n         // data is a dense array containing two entries and having a length of 2:\n         [Object, Object]\n         0: Object\n         1: Object\n         length: 2\n         // calling forEach on data will result in the callback being called two\n         // times, with the index parameter not matching the index of the key in the\n         // keyArray.\n         */\n        getBatch: function (keyArray, onSuccess, onError, arrayType) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n            arrayType || (arrayType = 'sparse');\n\n            if (Object.prototype.toString.call(keyArray) != '[object Array]') {\n                onError(new Error('keyArray argument must be of type Array.'));\n            } else if (keyArray.length === 0) {\n                return onSuccess([]);\n            }\n\n            var data = [];\n            var count = keyArray.length;\n            var called = false;\n            var hasSuccess = false;\n            var result = null;\n\n            var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            batchTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            batchTransaction.onabort = onError;\n            batchTransaction.onerror = onError;\n\n            var onItemSuccess = function (event) {\n                if (event.target.result || arrayType == 'dense') {\n                    data.push(event.target.result);\n                } else if (arrayType == 'sparse') {\n                    data.length++;\n                }\n                count--;\n                if (count === 0) {\n                    called = true;\n                    hasSuccess = true;\n                    result = data;\n                }\n            };\n\n            keyArray.forEach(function (key) {\n\n                var onItemError = function (err) {\n                    called = true;\n                    result = err;\n                    onError(err);\n                    batchTransaction.abort();\n                };\n\n                var getRequest = batchTransaction.objectStore(this.storeName).get(key);\n                getRequest.onsuccess = onItemSuccess;\n                getRequest.onerror = onItemError;\n\n            }, this);\n\n            return batchTransaction;\n        },\n\n        /**\n         * Fetches all entries in the store.\n         *\n         * @param {Function} [onSuccess] A callback that is called if the operation\n         *  was successful. Will receive an array of objects.\n         * @param {Function} [onError] A callback that will be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        getAll: function (onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n            var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            var store = getAllTransaction.objectStore(this.storeName);\n            if (store.getAll) {\n                this._getAllNative(getAllTransaction, store, onSuccess, onError);\n            } else {\n                this._getAllCursor(getAllTransaction, store, onSuccess, onError);\n            }\n\n            return getAllTransaction;\n        },\n\n        /**\n         * Implements getAll for IDB implementations that have a non-standard\n         * getAll() method.\n         *\n         * @param {IDBTransaction} getAllTransaction An open READ transaction.\n         * @param {IDBObjectStore} store A reference to the store.\n         * @param {Function} onSuccess A callback that will be called if the\n         *  operation was successful.\n         * @param {Function} onError A callback that will be called if an\n         *  error occurred during the operation.\n         * @private\n         */\n        _getAllNative: function (getAllTransaction, store, onSuccess, onError) {\n            var hasSuccess = false,\n                result = null;\n\n            getAllTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            getAllTransaction.onabort = onError;\n            getAllTransaction.onerror = onError;\n\n            var getAllRequest = store.getAll();\n            getAllRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            getAllRequest.onerror = onError;\n        },\n\n        /**\n         * Implements getAll for IDB implementations that do not have a getAll()\n         * method.\n         *\n         * @param {IDBTransaction} getAllTransaction An open READ transaction.\n         * @param {IDBObjectStore} store A reference to the store.\n         * @param {Function} onSuccess A callback that will be called if the\n         *  operation was successful.\n         * @param {Function} onError A callback that will be called if an\n         *  error occurred during the operation.\n         * @private\n         */\n        _getAllCursor: function (getAllTransaction, store, onSuccess, onError) {\n            var all = [],\n                hasSuccess = false,\n                result = null;\n\n            getAllTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            getAllTransaction.onabort = onError;\n            getAllTransaction.onerror = onError;\n\n            var cursorRequest = store.openCursor();\n            cursorRequest.onsuccess = function (event) {\n                var cursor = event.target.result;\n                if (cursor) {\n                    all.push(cursor.value);\n                    cursor['continue']();\n                }\n                else {\n                    hasSuccess = true;\n                    result = all;\n                }\n            };\n            cursorRequest.onError = onError;\n        },\n\n        /**\n         * Clears the store, i.e. deletes all entries in the store.\n         *\n         * @param {Function} [onSuccess] A callback that will be called if the\n         *  operation was successful.\n         * @param {Function} [onError] A callback that will be called if an\n         *  error occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        clear: function (onSuccess, onError) {\n            onError || (onError = defaultErrorHandler);\n            onSuccess || (onSuccess = defaultSuccessHandler);\n\n            var hasSuccess = false,\n                result = null;\n\n            var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);\n            clearTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            clearTransaction.onabort = onError;\n            clearTransaction.onerror = onError;\n\n            var clearRequest = clearTransaction.objectStore(this.storeName).clear();\n            clearRequest.onsuccess = function (event) {\n                hasSuccess = true;\n                result = event.target.result;\n            };\n            clearRequest.onerror = onError;\n\n            return clearTransaction;\n        },\n\n        /**\n         * Checks if an id property needs to present on a object and adds one if\n         * necessary.\n         *\n         * @param {Object} dataObj The data object that is about to be stored\n         * @private\n         */\n        _addIdPropertyIfNeeded: function (dataObj) {\n            if (typeof dataObj[this.keyPath] == 'undefined') {\n                dataObj[this.keyPath] = this._insertIdCount++ + Date.now();\n            }\n        },\n\n        /************\n         * indexing *\n         ************/\n\n        /**\n         * Returns a DOMStringList of index names of the store.\n         *\n         * @return {DOMStringList} The list of index names\n         */\n        getIndexList: function () {\n            return this.store.indexNames;\n        },\n\n        /**\n         * Checks if an index with the given name exists in the store.\n         *\n         * @param {String} indexName The name of the index to look for\n         * @return {Boolean} Whether the store contains an index with the given name\n         */\n        hasIndex: function (indexName) {\n            return this.store.indexNames.contains(indexName);\n        },\n\n        /**\n         * Normalizes an object containing index data and assures that all\n         * properties are set.\n         *\n         * @param {Object} indexData The index data object to normalize\n         * @param {String} indexData.name The name of the index\n         * @param {String} [indexData.keyPath] The key path of the index\n         * @param {Boolean} [indexData.unique] Whether the index is unique\n         * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry\n         */\n        normalizeIndexData: function (indexData) {\n            indexData.keyPath = indexData.keyPath || indexData.name;\n            indexData.unique = !!indexData.unique;\n            indexData.multiEntry = !!indexData.multiEntry;\n        },\n\n        /**\n         * Checks if an actual index complies with an expected index.\n         *\n         * @param {IDBIndex} actual The actual index found in the store\n         * @param {Object} expected An Object describing an expected index\n         * @return {Boolean} Whether both index definitions are identical\n         */\n        indexComplies: function (actual, expected) {\n            var complies = ['keyPath', 'unique', 'multiEntry'].every(function (key) {\n                // IE10 returns undefined for no multiEntry\n                if (key == 'multiEntry' && actual[key] === undefined && expected[key] === false) {\n                    return true;\n                }\n                // Compound keys\n                if (key == 'keyPath' && Object.prototype.toString.call(expected[key]) == '[object Array]') {\n                    var exp = expected.keyPath;\n                    var act = actual.keyPath;\n\n                    // IE10 can't handle keyPath sequences and stores them as a string.\n                    // The index will be unusable there, but let's still return true if\n                    // the keyPath sequence matches.\n                    if (typeof act == 'string') {\n                        return exp.toString() == act;\n                    }\n\n                    // Chrome/Opera stores keyPath squences as DOMStringList, Firefox\n                    // as Array\n                    if (!(typeof act.contains == 'function' || typeof act.indexOf == 'function')) {\n                        return false;\n                    }\n\n                    if (act.length !== exp.length) {\n                        return false;\n                    }\n\n                    for (var i = 0, m = exp.length; i < m; i++) {\n                        if (!( (act.contains && act.contains(exp[i])) || act.indexOf(exp[i] !== -1) )) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return expected[key] == actual[key];\n            });\n            return complies;\n        },\n\n        /**********\n         * cursor *\n         **********/\n\n        /**\n         * Iterates over the store using the given options and calling onItem\n         * for each entry matching the options.\n         *\n         * @param {Function} onItem A callback to be called for each match\n         * @param {Object} [options] An object defining specific options\n         * @param {String} [options.index=null] A name of an IDBIndex to operate on\n         * @param {String} [options.order=ASC] The order in which to provide the\n         *  results, can be 'DESC' or 'ASC'\n         * @param {Boolean} [options.autoContinue=true] Whether to automatically\n         *  iterate the cursor to the next result\n         * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n         *  duplicate matches\n         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n         * @param {Boolean} [options.writeAccess=false] Whether grant write access\n         *  to the store in the onItem callback\n         * @param {Function} [options.onEnd=null] A callback to be called after\n         *  iteration has ended\n         * @param {Function} [options.onError=throw] A callback to be called\n         *  if an error occurred during the operation.\n         * @param {Number} [options.limit=Infinity] Limit the number of returned\n         *  results to this number\n         * @param {Number} [options.offset=0] Skip the provided number of results\n         *  in the resultset\n         * @param {Boolean} [options.allowItemRejection=false] Allows the onItem\n         * function to return a Boolean to accept or reject the current item\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        iterate: function (onItem, options) {\n            options = mixin({\n                index: null,\n                order: 'ASC',\n                autoContinue: true,\n                filterDuplicates: false,\n                keyRange: null,\n                writeAccess: false,\n                onEnd: null,\n                onError: defaultErrorHandler,\n                limit: Infinity,\n                offset: 0,\n                allowItemRejection: false\n            }, options || {});\n\n            var directionType = options.order.toLowerCase() == 'desc' ? 'PREV' : 'NEXT';\n            if (options.filterDuplicates) {\n                directionType += '_NO_DUPLICATE';\n            }\n\n            var hasSuccess = false;\n            var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? 'READ_WRITE' : 'READ_ONLY']);\n            var cursorTarget = cursorTransaction.objectStore(this.storeName);\n            if (options.index) {\n                cursorTarget = cursorTarget.index(options.index);\n            }\n            var recordCount = 0;\n\n            cursorTransaction.oncomplete = function () {\n                if (!hasSuccess) {\n                    options.onError(null);\n                    return;\n                }\n                if (options.onEnd) {\n                    options.onEnd();\n                } else {\n                    onItem(null);\n                }\n            };\n            cursorTransaction.onabort = options.onError;\n            cursorTransaction.onerror = options.onError;\n\n            var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);\n            cursorRequest.onerror = options.onError;\n            cursorRequest.onsuccess = function (event) {\n                var cursor = event.target.result;\n                if (cursor) {\n                    if (options.offset) {\n                        cursor.advance(options.offset);\n                        options.offset = 0;\n                    } else {\n                        var onItemReturn = onItem(cursor.value, cursor, cursorTransaction);\n                        if (!options.allowItemRejection || onItemReturn !== false) {\n                            recordCount++;\n                        }\n                        if (options.autoContinue) {\n                            if (recordCount + options.offset < options.limit) {\n                                cursor['continue']();\n                            } else {\n                                hasSuccess = true;\n                            }\n                        }\n                    }\n                } else {\n                    hasSuccess = true;\n                }\n            };\n\n            return cursorTransaction;\n        },\n\n        /**\n         * Runs a query against the store and passes an array containing matched\n         * objects to the success handler.\n         *\n         * @param {Function} onSuccess A callback to be called when the operation\n         *  was successful.\n         * @param {Object} [options] An object defining specific options\n         * @param {String} [options.index=null] A name of an IDBIndex to operate on\n         * @param {String} [options.order=ASC] The order in which to provide the\n         *  results, can be 'DESC' or 'ASC'\n         * @param {Boolean} [options.filterDuplicates=false] Whether to exclude\n         *  duplicate matches\n         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n         * @param {Function} [options.onError=throw] A callback to be called\n         *  if an error occurred during the operation.\n         * @param {Number} [options.limit=Infinity] Limit the number of returned\n         *  results to this number\n         * @param {Number} [options.offset=0] Skip the provided number of results\n         *  in the resultset\n         * @param {Function} [options.filter=null] A custom filter function to\n         *  apply to query resuts before returning. Must return `false` to reject\n         *  an item. Can be combined with keyRanges.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        query: function (onSuccess, options) {\n            var result = [],\n                processedItems = 0;\n            options = options || {};\n            options.autoContinue = true;\n            options.writeAccess = false;\n            options.allowItemRejection = !!options.filter;\n            options.onEnd = function () {\n                onSuccess(result, processedItems);\n            };\n            return this.iterate(function (item) {\n                processedItems++;\n                var accept = options.filter ? options.filter(item) : true;\n                if (accept !== false) {\n                    result.push(item);\n                }\n                return accept;\n            }, options);\n        },\n\n        /**\n         *\n         * Runs a query against the store, but only returns the number of matches\n         * instead of the matches itself.\n         *\n         * @param {Function} onSuccess A callback to be called if the opration\n         *  was successful.\n         * @param {Object} [options] An object defining specific options\n         * @param {String} [options.index=null] A name of an IDBIndex to operate on\n         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use\n         * @param {Function} [options.onError=throw] A callback to be called if an error\n         *  occurred during the operation.\n         * @returns {IDBTransaction} The transaction used for this operation.\n         */\n        count: function (onSuccess, options) {\n\n            options = mixin({\n                index: null,\n                keyRange: null\n            }, options || {});\n\n            var onError = options.onError || defaultErrorHandler;\n\n            var hasSuccess = false,\n                result = null;\n\n            var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);\n            cursorTransaction.oncomplete = function () {\n                var callback = hasSuccess ? onSuccess : onError;\n                callback(result);\n            };\n            cursorTransaction.onabort = onError;\n            cursorTransaction.onerror = onError;\n\n            var cursorTarget = cursorTransaction.objectStore(this.storeName);\n            if (options.index) {\n                cursorTarget = cursorTarget.index(options.index);\n            }\n            var countRequest = cursorTarget.count(options.keyRange);\n            countRequest.onsuccess = function (evt) {\n                hasSuccess = true;\n                result = evt.target.result;\n            };\n            countRequest.onError = onError;\n\n            return cursorTransaction;\n        },\n\n        /**************/\n        /* key ranges */\n        /**************/\n\n        /**\n         * Creates a key range using specified options. This key range can be\n         * handed over to the count() and iterate() methods.\n         *\n         * Note: You must provide at least one or both of \"lower\" or \"upper\" value.\n         *\n         * @param {Object} options The options for the key range to create\n         * @param {*} [options.lower] The lower bound\n         * @param {Boolean} [options.excludeLower] Whether to exclude the lower\n         *  bound passed in options.lower from the key range\n         * @param {*} [options.upper] The upper bound\n         * @param {Boolean} [options.excludeUpper] Whether to exclude the upper\n         *  bound passed in options.upper from the key range\n         * @param {*} [options.only] A single key value. Use this if you need a key\n         *  range that only includes one value for a key. Providing this\n         *  property invalidates all other properties.\n         * @return {IDBKeyRange} The IDBKeyRange representing the specified options\n         */\n        makeKeyRange: function (options) {\n            /*jshint onecase:true */\n            var keyRange,\n                hasLower = typeof options.lower != 'undefined',\n                hasUpper = typeof options.upper != 'undefined',\n                isOnly = typeof options.only != 'undefined';\n\n            switch (true) {\n                case isOnly:\n                    keyRange = this.keyRange.only(options.only);\n                    break;\n                case hasLower && hasUpper:\n                    keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);\n                    break;\n                case hasLower:\n                    keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);\n                    break;\n                case hasUpper:\n                    keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);\n                    break;\n                default:\n                    throw new Error('Cannot create KeyRange. Provide one or both of \"lower\" or \"upper\" value, or an \"only\" value.');\n            }\n\n            return keyRange;\n\n        }\n\n    };\n\n    /** helpers **/\n    var empty = {};\n\n    function mixin (target, source) {\n        var name, s;\n        for (name in source) {\n            s = source[name];\n            if (s !== empty[name] && s !== target[name]) {\n                target[name] = s;\n            }\n        }\n        return target;\n    }\n\n    function hasVersionError(errorEvent) {\n        if ('error' in errorEvent.target) {\n            return errorEvent.target.error.name == 'VersionError';\n        } else if ('errorCode' in errorEvent.target) {\n            return errorEvent.target.errorCode == 12;\n        }\n        return false;\n    }\n\n    IDBStore.prototype = proto;\n    IDBStore.version = proto.version;\n\n    return IDBStore;\n\n}, this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}