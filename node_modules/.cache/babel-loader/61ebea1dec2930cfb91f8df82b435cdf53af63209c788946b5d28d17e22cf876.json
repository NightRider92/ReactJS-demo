{"ast":null,"code":"'use strict';\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n// shim for Node's 'util' package\n// DO NOT REMOVE THIS! It is required for compatibility with EnderJS (http://enderjs.com/).\nvar util = {\n  isArray: function (ar) {\n    return Array.isArray(ar) || typeof ar === 'object' && objectToString(ar) === '[object Array]';\n  },\n  isDate: function (d) {\n    return typeof d === 'object' && objectToString(d) === '[object Date]';\n  },\n  isRegExp: function (re) {\n    return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n  },\n  getRegExpFlags: function (re) {\n    var flags = '';\n    re.global && (flags += 'g');\n    re.ignoreCase && (flags += 'i');\n    re.multiline && (flags += 'm');\n    return flags;\n  }\n};\nif (typeof module === 'object') module.exports = clone;\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\n\nfunction clone(parent, circular, depth, prototype) {\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n  var useBuffer = typeof Buffer != 'undefined';\n  if (typeof circular == 'undefined') circular = true;\n  if (typeof depth == 'undefined') depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null) return null;\n    if (depth == 0) return parent;\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n    if (util.isArray(parent)) {\n      child = [];\n    } else if (util.isRegExp(parent)) {\n      child = new RegExp(parent.source, util.getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (util.isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      } else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n    if (circular) {\n      var index = allParents.indexOf(parent);\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n    return child;\n  }\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function (parent) {\n  if (parent === null) return null;\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};","map":{"version":3,"names":["objectToString","o","Object","prototype","toString","call","util","isArray","ar","Array","isDate","d","isRegExp","re","getRegExpFlags","flags","global","ignoreCase","multiline","module","exports","clone","parent","circular","depth","allParents","allChildren","useBuffer","Buffer","Infinity","_clone","child","proto","RegExp","source","lastIndex","Date","getTime","isBuffer","length","copy","getPrototypeOf","create","index","indexOf","push","i","attrs","getOwnPropertyDescriptor","set","clonePrototype","c"],"sources":["C:/Users/Moran/Documents/react-projects/react-demo/node_modules/clone/clone.js"],"sourcesContent":["'use strict';\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n// shim for Node's 'util' package\n// DO NOT REMOVE THIS! It is required for compatibility with EnderJS (http://enderjs.com/).\nvar util = {\n  isArray: function (ar) {\n    return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n  },\n  isDate: function (d) {\n    return typeof d === 'object' && objectToString(d) === '[object Date]';\n  },\n  isRegExp: function (re) {\n    return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n  },\n  getRegExpFlags: function (re) {\n    var flags = '';\n    re.global && (flags += 'g');\n    re.ignoreCase && (flags += 'i');\n    re.multiline && (flags += 'm');\n    return flags;\n  }\n};\n\n\nif (typeof module === 'object')\n  module.exports = clone;\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\n\nfunction clone(parent, circular, depth, prototype) {\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth == 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (util.isArray(parent)) {\n      child = [];\n    } else if (util.isRegExp(parent)) {\n      child = new RegExp(parent.source, util.getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (util.isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n      \n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}