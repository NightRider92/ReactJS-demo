{"ast":null,"code":"var util = require('util');\nvar AbstractIterator = require('abstract-leveldown').AbstractIterator;\nvar ltgt = require('ltgt');\nmodule.exports = Iterator;\nfunction Iterator(db, options) {\n  if (!options) options = {};\n  this.options = options;\n  AbstractIterator.call(this, db);\n  this._order = options.reverse ? 'DESC' : 'ASC';\n  this._limit = options.limit;\n  this._count = 0;\n  this._done = false;\n  var lower = ltgt.lowerBound(options);\n  var upper = ltgt.upperBound(options);\n  try {\n    this._keyRange = lower || upper ? this.db.makeKeyRange({\n      lower: lower,\n      upper: upper,\n      excludeLower: ltgt.lowerBoundExclusive(options),\n      excludeUpper: ltgt.upperBoundExclusive(options)\n    }) : null;\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just return 0 results.\n    this._keyRangeError = true;\n  }\n  this.callback = null;\n}\nutil.inherits(Iterator, AbstractIterator);\nIterator.prototype.createIterator = function () {\n  var self = this;\n  self.iterator = self.db.iterate(function () {\n    self.onItem.apply(self, arguments);\n  }, {\n    keyRange: self._keyRange,\n    autoContinue: false,\n    order: self._order,\n    onError: function (err) {\n      console.log('horrible error', err);\n    }\n  });\n};\n\n// TODO the limit implementation here just ignores all reads after limit has been reached\n// it should cancel the iterator instead but I don't know how\nIterator.prototype.onItem = function (value, cursor, cursorTransaction) {\n  if (!cursor && this.callback) {\n    this.callback();\n    this.callback = false;\n    return;\n  }\n  var shouldCall = true;\n  if (!!this._limit && this._limit > 0 && this._count++ >= this._limit) shouldCall = false;\n  if (shouldCall) this.callback(false, cursor.key, cursor.value);\n  if (cursor) cursor['continue']();\n};\nIterator.prototype._next = function (callback) {\n  if (!callback) return new Error('next() requires a callback argument');\n  if (this._keyRangeError) return callback();\n  if (!this._started) {\n    this.createIterator();\n    this._started = true;\n  }\n  this.callback = callback;\n};","map":{"version":3,"names":["util","require","AbstractIterator","ltgt","module","exports","Iterator","db","options","call","_order","reverse","_limit","limit","_count","_done","lower","lowerBound","upper","upperBound","_keyRange","makeKeyRange","excludeLower","lowerBoundExclusive","excludeUpper","upperBoundExclusive","e","_keyRangeError","callback","inherits","prototype","createIterator","self","iterator","iterate","onItem","apply","arguments","keyRange","autoContinue","order","onError","err","console","log","value","cursor","cursorTransaction","shouldCall","key","_next","Error","_started"],"sources":["C:/Users/Moran/Documents/react-projects/react-demo/node_modules/level-js/iterator.js"],"sourcesContent":["var util = require('util')\nvar AbstractIterator  = require('abstract-leveldown').AbstractIterator\nvar ltgt = require('ltgt')\n\nmodule.exports = Iterator\n\nfunction Iterator (db, options) {\n  if (!options) options = {}\n  this.options = options\n  AbstractIterator.call(this, db)\n  this._order = options.reverse ? 'DESC': 'ASC'\n  this._limit = options.limit\n  this._count = 0\n  this._done  = false\n  var lower = ltgt.lowerBound(options)\n  var upper = ltgt.upperBound(options)\n  try {\n    this._keyRange = lower || upper ? this.db.makeKeyRange({\n      lower: lower,\n      upper: upper,\n      excludeLower: ltgt.lowerBoundExclusive(options),\n      excludeUpper: ltgt.upperBoundExclusive(options)\n    }) : null\n  } catch (e) {\n    // The lower key is greater than the upper key.\n    // IndexedDB throws an error, but we'll just return 0 results.\n    this._keyRangeError = true\n  }\n  this.callback = null\n}\n\nutil.inherits(Iterator, AbstractIterator)\n\nIterator.prototype.createIterator = function() {\n  var self = this\n\n  self.iterator = self.db.iterate(function () {\n    self.onItem.apply(self, arguments)\n  }, {\n    keyRange: self._keyRange,\n    autoContinue: false,\n    order: self._order,\n    onError: function(err) { console.log('horrible error', err) },\n  })\n}\n\n// TODO the limit implementation here just ignores all reads after limit has been reached\n// it should cancel the iterator instead but I don't know how\nIterator.prototype.onItem = function (value, cursor, cursorTransaction) {\n  if (!cursor && this.callback) {\n    this.callback()\n    this.callback = false\n    return\n  }\n  var shouldCall = true\n\n  if (!!this._limit && this._limit > 0 && this._count++ >= this._limit)\n    shouldCall = false\n\n  if (shouldCall) this.callback(false, cursor.key, cursor.value)\n  if (cursor) cursor['continue']()\n}\n\nIterator.prototype._next = function (callback) {\n  if (!callback) return new Error('next() requires a callback argument')\n  if (this._keyRangeError) return callback()\n  if (!this._started) {\n    this.createIterator()\n    this._started = true\n  }\n  this.callback = callback\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}